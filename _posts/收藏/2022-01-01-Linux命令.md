---
title: "Linux 命令"
subtitle: "Linux 命令整理"
layout: post
author: "L Hondong"
header-img: "img/post-bg-15.jpg"
tags:
  - Linux
---

# Linux 命令

## 基本指令

|指令|作用|
|---|---|
|sudo {指令}|为指令增加暂时的超级权限|
|cd {path}|进入某个目录|
|ls {path}|显示某个目录的内容|
|mkdir {filename}|创建目录|
|cp {file} {path}|将 file 文件拷贝到 path 目录下 ，文件夹 -r|
|rm {file}|移除 file 文件，文件夹 -rf|
|mv {file1} {file2} /{path}|如果是文件到文件，则是改名，文件到路径，则是移动， 文件夹 -r|
|chmod ‘u+x’ -R filename|修改文件的权限，递归修改文件夹内所有文件（-R）|

## chmod

### 用户说明

|用户|用户类型|说明|
|---|---|---|
|u|uer|文件拥有者|
|g|group|文件所有者所在组|
|a|others|所有其他用户|

### 权限说明

|权限|说明|
|---|---|
|r|读|
|w|写|
|x|执行|

## 进程指令

|指令|作用|
|---|---|
|nvidia-smi -i|查看显卡情况，几号显卡|
|watch -n 0.5 nvidia-smi -i|按照 0.5 的频率查看显卡情况，几号显卡|
|CUDA_VISIBLE_DEVICES=0 {command}|指定显卡运行程序|
|top -c -u username|查看进程情况，以及具体运行指令，-u 指定用户|
|kill -9 ID|根据进程 ID kill 进程|
|nohup {command} &（>dev/null 2 >log &）|后台运行程序，输出错误日志|
|nohup {command} &（>dev/null 2 >&1 &）|后台运行程序，不输出任何日志|

## 目录
1. 统计当前目录下文件的个数（不包括目录）  
```bash
ls -l | grep "^-" | wc -l
```
2. 统计当前目录下文件的个数（包括子目录）  
```bash
ls -lR| grep "^-" | wc -l
```
3. 查看某目录下文件夹（目录）的个数（包括子目录）  
```bash
ls -lR | grep "^d" | wc -l
```

## Ubuntu 如何查看版本信息
1. 使用命令： cat /proc/version 查看
2. 使用命令： uname -a 查看
3. 使用命令： lsb_release -a 查看

## 上传服务器

把本地的 source.txt 文件拷贝到 192.168.0.10 机器上的/home/work 目录下
```
scp /home/work/source.txt work@192.168.0.10:/home/work/ 
```  

把 192.168.0.10 机器上的 source.txt 文件拷贝到本地的/home/work 目录下
```
scp work@192.168.0.10:/home/work/source.txt /home/work/   
```

把 192.168.0.10 机器上的 source.txt 文件拷贝到 192.168.0.11 机器的/home/work 目录下
```
scp work@192.168.0.10:/home/work/source.txt work@192.168.0.11:/home/work/   
```

拷贝文件夹，加-r 参数
```
scp -r /home/work/sourcedir work@192.168.0.10:/home/work/   
```

## 查找指令

### find

```bash
find .      #查找当前目录
find /home  #把 home 目录下的文件路径都显示出来
find /home -name "yezm.txt" -maxdepth 1   #查看/home 下的文件，返回 yezm.txt 的路径，-maxdepth 限制深度 1 层
find /path -type d (f)   #代表搜索的是 d: 目录，   f: 文件
find -user   #代表搜索某个用户下的文件
find /path -maxdepth 1 -type f -exec ls{}
"""根据时间戳查找文件，下列以天为单位"""
-atime（文件最后访问时间）
-mtime（文件最后修改时间）
-ctime（文件最后改变时间）
单位：
-amin
-mmin
-cmin
"""
#：[#, #-1) ：最后访问时间在#天前（大于等于#天前，小于#-1 天前），等价于最后访问时间与当前的时间差大于 (#-1)*24 小时，小于等于 #*24 小时
-#：(#, 0] ：最后访问时间在#天以内，不包括 24 小时前的那一刻，等价于最后访问时间与当前的时间差小于 #*24 小时
+#：(oo, #-1] ：最后访问时间在#-1 天以前的。包括#-1 天前，等价于最后访问时间与当前的时间差大于等于 #*24 小时
"""
```

### which

不同于 find 指令，which 指令是在 PATH 变量指定的路径中，搜索系统命令的位置，通过 which 可以锁定当前使用的软件的位置，重点是在系统（用户）的 PATH 变量内搜索的，具体下列：

```bash
which pip
result:/opt/anaconda/anaconda3/bin/pip
which python
result: /opt/anaconda/anaconda3/bin/python
```

### whereis

whereis 命令用于程序名的搜索，而且只搜索二进制文件（参数-b)、man 说明文件（参数-m)、源代码文件（参数-s).

和 find 相比，whereis 查找的速度非常快，因为 Linux 系统会将系统内的所有文件都记录在一个数据库文件中，当使用 whereis 和 locate 时，会从数据库中查找数据，而不是像 find 那样通过遍历硬盘来查找，效率自然会很高。

但是数据库文件并不是实时更新的，因此在用 whereis 和 locate 查找文件时，有时会找到已经被删除的数据，或者刚建立的文件无法被查找到，原因就使因为数据库文件没有被更新。

### locate

locate 让使用者可以很快速的搜索档案系统内是否有指定的档案。其方法就是先建立一个包括系统内所有档案名称及路径的资料库，之后当寻找时只需要查询这个资料库，而不必深入系统文件中查找了。

参数格式：
-u: 从根目录开始建立资料库。
-U：从指定位置开始建立资料库
-e: 将某些路径排除在寻找的范围外。
-n: 指定最多显示查找到的文件的个数

## 存储指令

### free

```bash
free -g  --查看系统的内存大小，以 g 为单位
```

返回结果：
- totol: 总的内存大小
- userd: 已经使用的内存大小
- free: 除了 buff/cache，还剩下多少内存未使用
- share: 共享内存
- buff/cache: 缓冲区的内存占用情况，page cache. 在内存不够用的时候，会自动使用这部分缓存。
- available: 真实可用的内存数。

buff/cache 可以通过手动清除进行缓存的释放：

```bash
sudo sh -c "echo 1 > /proc/sys/vm/drop_caches"  //1 释放 page cache ；2 释放 dentries 和 inodes；3 全部释放
```

### du -sh

查看文件大小

```bash
du -sh  #查看当前目录的总大小
du -sh /path/ * #查看目录下各个文件的大小
du -h /path/ * -d 2 表示查看目录下的文件大小， -d 指最大深度 --max-depth=2 
df -h  #列出磁盘总容量，可用容量，使用百分比。
```

## 重定向

### 输出描述符

|类型|文件描述符|默认情况|对应文件句柄位置|
|---|---|---|---|
|标准输入|0|从键盘获得输入|/proc/self/fd/0|
|标准输出|1|输出到屏幕|/proc/self/fd/1|
|标准输入|2|输出到屏幕|/proc/self/fd/2|

### 输出重定向

|类型|文件描述符|
|---|---|
|command >filename|标准输出重定向到新的文件中|
|command 1>filename|同上|
|command >>filename|把标准输出追加到新文件中|
|command 1>>filename|同上|
|command 2>filename|把标准错误重定向到新文件中|
|command 2>>filename|把标准错误追加到新文件中|

## 解压缩
### .tar
```bash
解包：tar xvf FileName.tar  
tar xvf FileName.tar -C DirName（解压到指定文件夹 DirName）  
打包：tar cvf FileNametar DirName
```

### .gz
```bash
解压 1：gunzip FileName.gz  
解压 2：gzip -d FileName.gz  
压缩：gzip FileName
```

### .tar.gz 和 .tgz
```bash
解压：tar zxvf FileName.tar.gz  
压缩：tar zcvf FileName.tar.gz FileName
```

### .bz2
```bash
解压 1：bzip2 -d FileName.bz2  
解压 2：bunzip2 FileName.bz2  
压缩： bzip2 -z FileName
```
### .tar.bz2
```bash
解压：tar jxvf FileName.tar.bz2  
压缩：tar jcvf FileName.tar.bz2 FileName
```

### .bz
```bash
解压 1：bzip2 -d FileName.bz  
解压 2：bunzip2 FileName.bz  
压缩：未知
```
### .tar.bz
```bash
解压：tar jxvf FileName.tar.bz  
压缩：tar jcvf FileName.tar.bz FileName
```

### .z
```bash
解压：uncompress FileName.Z  
压缩：compress FileName.tar.z  
解压：tar zxvf FileName
```
### .tar.z
```bash
解压：tar zxvf FileName.tar.z  
压缩：tar zcvf FileName.tar.z DirName
```

### .zip
```bash
解压：unzip FileName.zip  
压缩：zip FileName.zip DirName
```

### .rar
```bash
解压：rar x FileName.rar  
压缩：rar a FileName.rar DirName  
rar 请到：http://www.rarsoft.com/download.htm 下载  
解压后请将 rar_static 拷贝到/usr/bin 目录（其他由$PATH 环境变量指定的目录也可以）[root@www2 tmp]# cp rar_static /usr/bin/rar
```

### .lha
```bash
解压：lha -e FileName.lha  
压缩：lha -a FileName.lha FileName  
lha 请到：http://www.infor.kanazawa-it.ac.jp/~ishii/lhaunix/下载！  
解压后请将 lha 拷贝到/usr/bin 目录（其他由$PATH 环境变量指定的目录也可以）[root@www2 tmp]# cp lha /usr/bin/
```

### .rpm
```bash
解包：rpm2cpio FileName.rpm | cpio -div
```

### .deb
```bash
解包：ar p FileName.deb data.Tar.gz | Tar zxf -
```

##  用户命令

```bash
sudo adduer --home /home/Username Username   #添加用户，并且生成用户目录
sudo passwd Username   #修改用户的用户密码
sudu userdel -r Username # 删除所有与用户有关（需要先把该用户的所有进程关闭）
```

adduser 和 useradd 指令不同，useradd 只会添加一个用户，没有创建它的主目录，除了添加一个新用户之外什么都没有。这个用户甚至不能登录，因为没有密码。正确的做法是 man page 里说的，adduser，这个命令实际是一个 perl 脚本，是 useradd 等类似底层命令的更友好的前端，它会用交互性的方式建立新用户，使用它可以指定新用户的家目录，登录密码，是否加密主目录等等。adduser 会：

1. 建立一个新目录作为家目录
2. 建立同名新组
3. 把用户的主要组设为该组(除非命令选项覆盖以上默认动作，比如–disall-homdirecry之类)
4. 从/etc/SKEL目录下拷贝文件到家目录，完成初始化
5. 建立新用户的密码
6. 如果其存在的话，还会执行一个脚本。