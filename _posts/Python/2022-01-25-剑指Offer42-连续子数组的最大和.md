---
title: "剑指 Offer 42. 连续子数组的最大和"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 42. 连续子数组的最大和

## 题目

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

## 示例

示例 1:

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

## 题解

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [nums[0]]
        for i in range(1, len(nums)):
            dp.append(nums[i] + max(dp[i-1], 0))
        return max(dp)
```

## 笔记

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/剑指Offer42-连续子数组的最大和-2022-01-25-23-06-43.png" alt="剑指Offer42-连续子数组的最大和-2022-01-25-23-06-43" style="zoom:50%;" /></div>

- 状态定义：设动态规划列表 dp，dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和。
  - 为何定义最大和 dp[i] 中必须包含元素 nums[i] ：保证 dp[i] 递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的**连续子数组**要求。
- 转移方程：若dp[i−1]≤0 ，说明 dp[i−1] 对 dp[i] 产生负贡献，即 dp[i−1]+nums[i] 还不如 nums[i] 本身大。
  - 当 dp[i−1]>0 时：执行 dp[i]=dp[i−1]+nums[i]；
  - 当 dp[i−1]≤0 时：执行 dp[i]=nums[i] ；
- 初始状态： dp[0]=nums[0]，即以 nums[0] 结尾的连续子数组最大和为 nums[0] 。
- 返回值： 返回 dp 列表中的最大值，代表全局最大值。

### 空间复杂度降低

- 由于 dp[i] 只与 dp[i−1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums 上修改即可。
- 由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1, len(nums)):
            nums[i] += max(nums[i - 1], 0)
        return max(nums)
```
