---
title: "剑指 Offer 59 滑动窗口的最大值"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 59 - I. 滑动窗口的最大值

## 题目

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

## 示例

示例 1:

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

## 笔记

设窗口区间为 $[i,j]$，最大值为 $x_j$。当窗口向前移动一格，则区间变为 $[i+1,j+1]$，即添加了 $nums[j+1]$，删除了 $nums[i]$。

若只向窗口 $[i,j]$ 右边添加数字 $nums[j+1]$，则新窗口最大值可以通过一次对比使用 $O(1)$ 时间得到，即：

$$x_{j+1}=\max(x_j,nums[j+1])$$

而由于删除的 $nums[i]$ 可能恰好是窗口内唯一的最大值，因此不能通过以上方法计算 $x_j+1$，而必须使用 $O(j−i)$ 时间，遍历整个窗口区间获取最大值，即：

$$x_{j+1}=\max(nums[i+1],\cdots,num[j+1])$$

根据以上分析，可得暴力法的时间复杂度为 $O((n−k+1)k)≈O(nk)$。

- 设数组 $nums$ 的长度为 $n$，则共有 $(n−k+1)$ 个窗口；
- 获取每个窗口最大值需线性遍历，时间复杂度为 $O(k)$。

<div align=center><img src="/Assets/Images/剑指Offer59-滑动窗口的最大值-2022-02-17-17-00-20.png" alt="剑指Offer59-滑动窗口的最大值-2022-02-17-17-00-20" style="zoom:50%;" /></div>

### 优化

在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 $O(k)$ 降低至 $O(1)$。

回忆[剑指Offer 30. 包含 min 函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/)，使用单调栈实现了随意入栈、出栈情况下的 $O(1)$ 时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” 。

窗口对应的数据结构为双端队列，使用单调队列。遍历数组时，每轮保证单调队列 $deque$：

1. $deque$ 内仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 $nums[i−1]$，需将 $deque$ 内的对应元素一起删除。
2. $deque$ 内的元素非严格递减 ⇒ 每轮窗口滑动添加了元素 $nums[j+1]$，需将 $deque$ 内所有 $<nums[j+1]$ 的元素删除。

### 算法流程

1. 初始化：双端队列 $deque$，结果列表 $res$，数组长度 $n$；
2. 滑动窗口：左边界范围 $i\in[1−k,n−k]$，右边界范围 $j\in[0,n−1]$；
   1. 若 $i>0$ 且队首元素 $deque[0] =$ 被删除元素 $nums[i−1]$：则队首元素出队；
   2. 删除 $deque$ 内所有 $<nums[j]$ 的元素，以保持 $deque$ 递减；
   3. 将 $nums[j]$ 添加至 $deque$ 尾部；
   4. 若已形成窗口（即 $i\geq 0$ ）：将窗口最大值（即队首元素 $deque[0]$）添加至列表 $res$；
3. 返回值：返回结果列表 $res$；

### 复杂度分析

- 时间复杂度 $O(n)$：其中 $n$ 为数组 $nums$ 长度；线性遍历 $nums$ 占用 $O(n)$；每个元素最多仅入队和出队一次，因此单调队列 $deque$ 占用 $O(2n)$。
- 空间复杂度 $O(k)$：双端队列 $deque$ 中最多同时存储 $k$ 个元素（即窗口大小）。

### python zip 函数

zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

```python
zip([iterable, ...])
例子：
a = [1,2,3]
b = [4,5,6]
c = [4,5,6,7,8]
zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]
```

## 题解

```python
import collections

def solution(nums, k):
    res = []
    deque = collections.deque()
    for i, j in zip(range(1 - k, len(nums) + 1 - k), range(len(nums))):
        if i > 0 and deque[0] == nums[i-1]:
            deque.popleft()
        while deque and deque[-1] < nums[j]:
            deque.pop()
        deque.append(nums[j])
        if i >= 0:
            res.append(deque[0])
    return res
```

### 简化

可以将 “未形成窗口” 和 “形成窗口后” 两个阶段拆分到两个循环里实现。代码虽变长，但减少了冗余的判断操作。

```python
def solution(nums, k):
    if not nums or k == 0: return []
    deque = collections.deque()
    res = []
    # 未形成窗口
    for i in range(k):
        while deque and deque[-1] < nums[i]:
            deque.pop()
        deque.append(nums[i])
    res.append(deque[0])
    # 形成窗口后
    for i in range(k, len(nums)):
        if deque[0] == nums[i-k]:
            deque.popleft()
        while deque and deque[-1] < nums[i]:
            deque.pop()
        deque.append(nums[i])
        res.append(deque[0])
    return res
```

```python
def solution(nums, k):
    if not nums or k == 0: return []
    res = []
    right = 0
    deque = collections.deque()
    # 开始构造窗口
    while right < len(nums):
        # 这里的 deque 的首位必须是窗口中最大的那个
        while deque and nums[right] > deque[-1]:
            deque.pop()
        # 不断添加
        deque.append(nums[right])
        right += 1
        # 构造窗口完成，这时候需要根据条件做一些操作
        if right - k >= 0:
            res.append(deque[0])
            # 如果发现第一个已经在窗口外面了，就移除
            if deque[0] == nums[right-k]:
                deque.popleft()
    return res
```