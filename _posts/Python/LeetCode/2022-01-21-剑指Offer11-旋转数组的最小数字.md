---
title: "剑指 Offer 11. 旋转数组的最小数字"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 11. 旋转数组的最小数字

## 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在**重复**元素值的数组 `numbers`，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为1。

## 示例

示例 1:

```
输入：[3,4,5,1,2]
输出：1
```

示例 2:

```
输入：[2,2,2,0,1]
输出：0
```

## 题解

```python
class Solution(object):
    def minArray(self, numbers):
        """
        :type numbers: List[int]
        :rtype: int
        """
        lo = 0
        hi = len(numbers) - 1
        while lo < hi:
            mid = (hi + lo) // 2
            if numbers[mid] > numbers[hi]: lo = mid + 1
            elif numbers[mid] < numbers[lo]: hi = mid
            else: hi -= 1
        return numbers[lo]
```

## 笔记

- 当 nums[m]>nums[j] 时：m 一定在左排序数组中，即旋转点 x 一定在 [m+1,j] 闭区间内，因此执行 i=m+1；
- 当 nums[m]<nums[j] 时：m 一定在右排序数组中，即旋转点 x 一定在 [i,m] 闭区间内，因此执行 j=m；
- 当 nums[m]=nums[j] 时：无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i,m] 还是 [m+1,j] 区间中。解决方案：执行 j=j−1 缩小判断范围。

### 正确性证明：

当 nums[m] = nums[j] 时，无法判定 m 在左侧还是右侧。比如 [1,0,1,1,1]，旋转点 x=1，因此 m=2 在右排序数组中。再比如[1,1,1,0,1]，旋转点 x=3，因此 m=2 在右排序数组中。

而证明 j=j-1 正确，分两种情况：

1. 当 x < j 时，执行 j=j-1 之后，旋转点 x 仍在区间 [i,j] 中。
2. 当 x = j 时，执行 j=j-1 之后越过了旋转点 x，但最终返回的元素值 nums[i] 仍等于旋转点的值 nums[x]。
   1. 由于 x=j，因此 nums[x]=nums[j]=nums[m]≤nums[i]；
   2. 又由于i ≤ m < j 恒成立，因此 m < x ，即此时 m 一定在左排序数组中，因此 nums[m]≥nums[i]；

综上可推出，nums[i]=nums[j]，且区间 [i,m] 内所有元素值相等。

此时，执行 j=j−1 后虽然丢失了旋转点 x ，但之后区间 [i,j] 只包含左排序数组，二分下去返回的一定是本轮的 nums[i] ，而其与 nums[x] 相等。


### 为什么本题二分法不用 nums[m] 和 nums[i] 作比较？

二分目的是判断 m 在哪个排序数组中，从而缩小区间。而在 nums[m]>nums[i]情况下，无法判断 m 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中；i 初始值无法确定在哪个排序数组中。举例如下：

对于以下两示例，当 i=0,j=4,m=2 时，有 nums[m] > nums[i] ，而结果不同。

- [1,2,3,4,5] 旋转点 x=0：m 在右排序数组（此示例只有右排序数组）；
- [3,4,5,1,2] 旋转点 x=3 ：m 在左排序数组。