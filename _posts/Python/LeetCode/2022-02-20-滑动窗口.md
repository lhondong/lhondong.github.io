---
title: "字符串划分"
subtitle: "微软笔试笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - Microsoft
  - 算法
---

# 滑动窗口

## 题目

A storeroom is used to organize items stored in it on N shelves. Shelve are numbered from 0 to N-1. The K-th shelf is dedicated to items of only one type, denoted by a positive integer A[K].

Recently it was decided that it is necessary to free R consecutive shelves. Shelves cannot be reordered. What is the maximum number of types of items which still can be stored in the storeroom after freeing R consecutive shelves?

## 示例

示例 1:

```
Given A = [2, 1, 2, 3, 2, 2] and R = 3, your function should return 2. 
It can be achieved, for example, by freeing shelves 2, 3 and 4 (shelves are numbered from 0).
```

示例 2:

```
Given A = [2, 3, 1, 1, 2] and R = 2, your function should return 3. 
All three types can still be stored by freeing the last two shelves.
```

示例 3:

```
Given A = [20, 10, 10, 10, 30, 20] and R = 3, your function should return 3. 
It can be achieved by freeing the first three shelves.
```

示例 4:

```
Given A = [1, 100000, 1] and R = 3, your function should return 0. 
All shelves need to be freed.
```

## 笔记

对于非固定大小的滑动窗口，伪码框架：

```python
# s, t(string)，在 s 中寻找 t 的「最小覆盖子串」
left, right = 0, 0
res = s

while right < len(s):
    window.add(s[right])
    right += 1
    # 如果符合要求，说明窗口构造完成，移动 left 缩小窗口
    while window 符合要求:
        # 如果这个窗口的子串更短，则更新 res
        res = min(res, s[left:right])
        window.remove(s[left])
        left += 1
return res
```

固定窗口大小，可以总结如下：

```python
# 固定窗口大小为 k
# 在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数
right = 0

while right < len(s):
    window.add(s[right])
    right += 1
    # 如果符合要求，说明窗口构造完成，
    if right >= k:
        # 这是已经是一个窗口了，根据条件做一些事情
        # ... 可以计算窗口最大值等 
        # 最后不要忘记把 right - k 位置元素从窗口里面移除
return res
```

## 题解

```python
def solution(A, R):
    if not A or R == len(A): return 0
    dict = {}
    for i in A:
        if i in dict: dict[i] += 1
        else: dict[i] = 1
    right, left, ans = 0, 0, 0
    while right < len(A):
        dict[A[right]] -= 1
        right += 1
        if right >= R:
            res = 0
            for i in dict:
                if dict[i] > 0:
                    res += 1
            ans = max(ans, res)
            dict[A[left]] += 1
            left += 1
    return ans
```

使用 dcit 记录所有的种类及其数量，滑动窗口中的所有种类的数量都要减去，右端 right 表示新进窗口的，在 dict 中相对应的种类数量减 1，左端 left 表示刚出窗口的，在 dict 中相对应的种类数量加 1，然后统计 dict 中非零的种类，最后计算所有窗口的最大值。