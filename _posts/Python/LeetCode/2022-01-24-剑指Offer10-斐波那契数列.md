---
title: "剑指 Offer 10- I. 斐波那契数列"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 10- I. 斐波那契数列

## 题目

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

## 示例

示例 1:

```
输入：n = 2
输出：1
```

## 题解

```python
def fib(n):
  if n <= 1:
    return n
  return fib(n-1) + fib(n-2) % 1000000007
```

<div align=center><img src="/assets/剑指Offer10-斐波那契数列-2022-01-24-13-42-56.png" alt="剑指Offer10-斐波那契数列-2022-01-24-13-42-56" style="zoom:50%;" /></div>

大量重复的递归计算，例如 f(n) 和 f(n−1) 两者向下递归需要各自计算 f(n−2) 的值，会导致超时。时间复杂度 $O(2^N)$。

### 记忆化递归

同样的子问题可能会被求解多次，这样就会很慢很慢很慢。

解决方法：把历史求解（子问题）记录下来，如果下次需要求解子问题，那么直接取出就好。其时间复杂度为 O(1)。

```python
def fibonacci(n, dp):
    dp = [0] * (n + 1)
    if n == 0: return 0           # 返回 f(0)
    if n == 1: return 1           # 返回 f(1)
    if dp[n] != 0: return dp[n]   # 若 f(n) 以前已经计算过，则直接返回记录的解
    dp[n] = fibonacci(n - 1, dp) + fibonacci(n - 2, dp) # 将 f(n) 则记录至 dp
    return dp[n]
```

简化：

```python
class Solution(object):
    def fib(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [0,1]
        for i in range(2, n+1):
            dp.append(dp[i-1]+dp[i-2])
        return dp[n] % 1000000007
```

记忆化递归的模版：

```python
def f(n):
    if n <= 1: return n
    if not m[n]:
        m[n] = f(n-1) + f(n-2)
    return m[n]
```

其中，`n <= 1` 是边界区域，`m[n] = f(n-1) + f(n-2)` 是求解子问题。

- 时间复杂度：O(N)
- 空间复杂度：O(N)

#### 优势

动态规划是有先后顺序的，子问题求解后才能求解父问题。因此要小心确保问题求解的顺序，从而避免bug。

但是记忆化递归，当子问题没有求解时，程序会自动去求解。而不需要小心翼翼的去确保顺序，减轻工作量。

#### 劣势

因为动态规划时有先后顺序的，因此实际上有一些求解的子问题用不到了可以将空间释放掉。

而记忆化递归再这种优化上就很难。

故记忆化递归可能在空间复杂度上比不上精心设计的动态规划。

但是！！！这里是精心设计的动态规划，为了精心设计，我们可能会花很长的时间去写控制规则，为了减少那么一丢丢的内存。但是实际上我们刷题，失败的原因往往是超时！！！而不是超出内存限制。

### 动态规划

- 状态定义：设 dp 为一维数组，其中 dp[i] 的值代表斐波那契数列第 i 个数字。
- 转移方程：dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1)；
- 初始状态：dp[0]=0, dp[1]=1 ，即初始化前两个数字；
- 返回值：dp[n] ，即斐波那契数列的第 n 个数字。

空间复杂度优化：

若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。

由于 dp 列表第 i 项只与第 i−1 和第 i−2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sum 使 a,b 两数字交替前进即可。节省了 dp 列表空间，因此空间复杂度降至 O(1) 。

```python
class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a % 1000000007
```

```java
class Solution {
    public int fib(int n) {
        int a = 0, b = 1, sum;
        for(int i = 0; i < n; i++){
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }
        return a;
    }
}
```

这里要将 f(n) = f(n-1) + f(n-2) 算出来，实际上要先将 f(n+1) 算出来。因此 b 记录 f(n+1)，a 记录 f(n)，最后直接返回 n 即可。

- 时间复杂度：O(N)
- 空间复杂度：O(1)

### 矩阵幂方法

$$
\left[\begin{matrix}
1 & 1 \\
1 & 0
\end{matrix}\right]\left[\begin{matrix}
F(n) \\
F(n-1)
\end{matrix}\right]=\left[\begin{matrix}
F(n)+F(n-1) \\
F(n)
\end{matrix}\right]=\left[\begin{matrix}
F(n+1) \\
F(n)
\end{matrix}\right]
$$

因此：

$$
\left[\begin{matrix}
F(n+1) \\
F(n)
\end{matrix}\right]=\left[\begin{matrix}
1 & 1 \\
1 & 0
\end{matrix}\right]^n\left[\begin{matrix}
F(1) \\
F(0)
\end{matrix}\right]
$$

令：

$$
M=\left[\begin{matrix}
1 & 1 \\
1 & 0
\end{matrix}\right]
$$

因此只要快速计算矩阵 M 的 n 次幂，就可以得到 F(n) 的值。如果直接求取 $M^n$，时间复杂度是 O(n)，可以定义矩阵乘法，然后用快速幂算法来加速这里 $M^n$ 的求取。

```python
class Solution(object):
    def fib(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 1000000007
        if n <= 1: return n

        def matrix_multiple(a,b):
            c = [[0,0],[0,0]]
            for i in range(2):
                for j in range(2):
                    c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % MOD
            return c
            
        def matrix_power(m,n):
            power = [[1,0],[0,1]]
            while n-1:
                power = matrix_multiple(power,m)
                n -= 1
            return power

        a = [[1,1],[1,0]]
        return matrix_power(a,n)[0][0] % MOD
```

即：

$$
F(n) = M^{n-1}_{00}
$$

- 时间复杂度：O(log N)
- 空间复杂度：O(1)