---
title: "剑指 Offer 24. 反转链表"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 24. 反转链表

## 题目

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

## 示例

示例 1:

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

限制

```
0 <= 节点个数 <= 5000
```

## 题解

### 迭代（双指针）

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        preNode = None
        currNode = head
        while currNode:
            nextNode = currNode.next
            currNode.next = preNode
            preNode = currNode
            currNode = nextNode
        return preNode
```

考虑遍历链表，并在访问各节点时修改 `next` 引用指向，算法流程见注释。

复杂度分析：

- 时间复杂度：$O(N)$，遍历链表使用线性大小时间。
- 空间复杂度：$O(1)$，变量 `pre` 和 `cur` 使用常数大小额外空间。

<div align=center><img src="/Assets/Images/剑指Offer24-反转链表-2022-01-18-20-55-51.png" alt="剑指Offer24-反转链表-2022-01-18-20-55-51" style="zoom:50%;" /></div>

<div align=center><img src="/Assets/Images/剑指Offer24-反转链表-2022-01-18-20-56-18.png" alt="剑指Offer24-反转链表-2022-01-18-20-56-18" style="zoom:50%;" /></div>

### 递归

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return head
        node = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return node
```

递归，从最后一个节点开始，每个节点指向它前面的节点，并且保证最后一个节点指向空。

## 递归问题总结整理

> Rules Number One: 基本上，所有的递归问题都可以用递推公式来表示。有了这个递推公式，就可以很轻松地将它改为递归代码。所以，遇到递归不要怕，先想递推公式。

### 例 1: （比较明显的能递推公式的问题）

- 问题：斐波那契数列的第 n 项
- 递推公式：
```
f(n) = f(n-1) + f(n-2) 其中，f(0) = 0,f(1) = 1
```
终止条件：
```
if (n <= 2) return 1;
```
递归代码：
```
int f(int n) {
  if (n <= 2) return 1;
  return f(n-1) + f(n-2);
}
```

### 例 2: （不那么明显的有递推公式的问题）

- 问题：逆序打印一个数组
- 递推公式：
```
假设令 F(n) = 逆序遍历长度为 n 的数组
那么 F(n) = 打印数组中下标为 n 的元素 + F(n-1)
```
终止条件：
```
if (n <0) return ;
```
递归代码：
```
public void Print(int[] nums,int n){
    if(n < 0) return;
    System.out.println(nums[n]);
    Print(nums,n-1);
}
```

到这里，应该对写递归有一些理解了。其实写递归不能总想着去把递归平铺展开，这样脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。只要找到递推公式，就能很轻松地写出递归代码。

进一步，就树的遍历问题来深入理解递归。递归总是和树分不开，其中，最典型的便是树的遍历问题。以前序遍历为例：

### 二叉树的先序遍历

- 问题：二叉树的先序遍历
- 递推公式：

```
令 F(Root) 为问题：遍历以 Root 为根节点的二叉树，
令 F(Root.left) 为问题：遍历以 F(Root.left) 为根节点的二叉树
令 F(Root.right) 为问题：遍历以 F(Root.right) 为根节点的二叉树
```

那么其递推公式为：
```
F(Root) = 遍历 Root 节点 + F(Root.left) + F(Root.right)
```

递归代码：

```
public void preOrder(TreeNode node){
    if(node==null) return;
    System.out.println(node.val);
    preOrder(node.left);
    preOrder(node.righr);
}
```

> Rules Number Two: 递归是一种关于某个重复动作（完成重复性的功能）的形式化描述。具体点讲，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系（也就是说，递归只能考虑当前层和下一层的关系，不能继续往下深入）。我们需要屏蔽掉递归细节，理解为完成了某种功能的形式化描述即可。

### 例3: 单向链表的反转

- 问题：单向链表的反转
- 递推公式：
```
令 F(node) 为问题：反转以 node 为头节点的单向链表；
令 F(node.next) 为问题：反转以 node.next 为头节点的单向链表；
```

一般，我们需要考虑 F(n) 和 F(n-1) 的关系，那么这里，如果 n 代表以 node 为头节点的单向链表，那么 n-1 就代表以 node.next 为头节点的单向链表。

所以令 F(node.next) 为问题：反转以 node.next 为头节点的单向链表；那么，F(node) 和 F(node.next) 之间的关系是？这里简单画个图，假设 3 个节点的链表：

```
1 -> 2 -> 3
```

那么，F(node=1) = F(node=2) + ?

这里假设子问题 F(node=2) 已经解决，那么如何解决 F(node=1)？

很明显，需要反转 node=2 和 node=1， 即 node.next.next=node；同时 node.next=null；

所以，这个问题就是：F(node=1) = F(node=2)+ 反转 F(node=2)与 node=1

递归代码：

```
public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) {  //终止条件并不难想
            return head;
        }
        ListNode node = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return node;  //按上面的例子，F(node=1) 和 F(node=2) 它俩反转后的头节点是同一个
    }
```