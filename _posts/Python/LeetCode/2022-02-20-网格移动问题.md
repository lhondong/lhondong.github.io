---
title: "网格移动问题"
subtitle: "微软笔试笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - Microsoft
  - 算法
---

# 网格移动问题

## 题目

一个 3×3 网格，其中在其单元格内恰好包含 9 块石头。一个单元格可以包含任意数量的石头。在每次移动中，如果两个单元格共用一面，则可以将石头从一个单元格移动到另个单元格。

网格由了 3×3 整数 A 矩阵描述。行从上到下按 0 到 2 的编号，列从左到右按 0 到 2 的编号。A[K][J] 表示位于第 K 行和第 J 列交点的单元格中的石头数量。

## 示例

示例 1:

<div align=center><img src="/Assets/Images/网格移动问题-2022-02-14-09-28-00.png" alt="网格移动问题-2022-02-14-09-28-00" style="zoom:30%;" /></div>

```
给定 A = []，函数应返回 3。[1,0,1], [1,3,0] ,[2,0,1]
可以将石头从（1,1）移动到（0,1)，从（1,1）移动到（1,2）以及从（2,0）移动到 (2,1）。
```

示例 2:

```
给定 A = [[2,0,2], [1,0,0], [2,1,1]]，应返回 4。
```

## 题解

```python
def solution(A):
    vacant = []  # 空白的位置
    multi = []  # 有多个stones的位置

    ## 计算重心
    def get_center(A):
        row_center = (0 * (A[0][0] + A[0][1] + A[0][2]) + 
                        1 * (A[1][0] + A[1][1] + A[1][2]) +
                        2 * (A[2][0] + A[2][1] + A[2][2])) / 9
        col_center = (0 * (A[0][0] + A[1][0] + A[2][0]) +
                        1 * (A[0][1] + A[1][1] + A[2][1]) +
                        2 * (A[0][2] + A[1][2] + A[2][2])) / 9
        return (row_center, col_center)

    # 第一遍循环 把空白的和多个的都记录下来
    for i in range(len(A)):
        for j in range(len(A[0])):
            if A[i][j] == 0: vacant.append([i,j])
            if A[i][j] > 1: multi.append([i,j])

    dis = 0
    # 把多个的放到空白的位置
    for i in vacant:
        min_dis = 5 ## 记录最小的距离
        min_local = [0,0] ## 记录最小的距离的位置
        for j in multi: 
            if min_dis == abs(i[0] - j[0]) + abs(i[1] - j[1]):
                row_center, col_center = get_center(A)
                if (row_center - j[0]) ** 2 + (col_center - j[1]) < (row_center - min_local[0]) ** 2 + (col_center - min_local[1]):
                    min_local = j
                    min_dis = abs(i[0] - j[0]) + abs(i[1] - j[1])
            if min_dis > abs(i[0] - j[0]) + abs(i[1] - j[1]):
                min_local = j
                min_dis = abs(i[0] - j[0]) + abs(i[1] - j[1])
        A[min_local[0]][min_local[1]] -= 1
        if A[min_local[0]][min_local[1]] == 1:
            multi.remove(min_local) # 删除已经放好的
        dis += min_dis
    
    return dis
```

## 笔记

### 重心法

9 个格子中石子数为 1 的格子是不需要移动的，故主要讨论的是石子数大于 1 和 0 的格子。

- 首先求此棋盘的重心，用浮点数表示。
- 对石子数为 0 的格子依次进行讨论，查看最近的一个大于 1 格子位置，记录移动距离。
- 若遇到多个距离相同的大于 1 的格子，则选择这些格子中离重心更近的格子。
- 若这些格子中有多个离重心距离相同，则说明从其中哪个移动都行。
- 每移动一块石头后重新计算重心位置，然后再讨论下一个石子数为 0 的格子。最后得到其中最小的总移动次数。

$$
\begin{gathered}
\operatorname{row}_{\text {重}}=\frac{1}{9}\left(\begin{array}{c}
a_{00} \times 0+a_{01} \times 0+a_{02} \times 0 \\
+a_{10} \times 1+a_{11} \times 1+a_{12} \times 1 \\
+a_{20} \times 2+a_{21} \times 2+a_{22} \times 2
\end{array}\right) \\
\operatorname{col}_{\text {重}}=\frac{1}{9}\left(\begin{array}{c}
a_{00} \times 0+a_{01} \times 1+a_{02} \times 2 \\
+a_{10} \times 0+a_{11} \times 1+a_{12} \times 2 \\
+a_{20} \times 0+a_{21} \times 1+a_{22} \times 2
\end{array}\right)
\end{gathered}
$$

然后再对石子数为 0 处的格子寻找曼哈顿距离最近的石子数大于 1 的格子，若存在多个格子曼哈顿距离相同，则取其中离重心直线距离最近的那个格子（因为离重心越近表示此处石子密度越大），如果也存在多个格子离重心直线距离相同，选其中任一均可。

例如初始矩阵 $A =[[0, 1, 3],[1, 0, 0],[2, 0, 2]]$，先求得此时矩阵的重心位置为 (1, 1.22)；此时有 3 个大于 1 的格子，分别是 (0, 2) 的 3、(2, 0) 的 2、(2, 2) 的 2；其中与 (0, 0) 曼哈顿距离最近的是 (0, 2) 和 (2, 0)，其中这两格距离重心更近的是 (0, 2) 的 3，故选择 (0, 2) 的一个石子移动到 (0, 0)，移动总数暂时为 2。

矩阵变为 $[[1, 1, 2], [1, 0, 0], [2, 0, 2]]$，求得此时矩阵的重心位置为 (1, 1)；此时有 3 个大于 1 的格子，分别是 (0, 2) 的 2、(2, 0) 的 2、(2, 2) 的 2；这 3 格与 (1, 1) 曼哈顿距离相同，与重心直线距离也相同，随便选其中之一移动石子都一样，移动总数暂时为 2+2=4。

其实重心为 (1, 1) 时，主对角线、副对角线、横、纵、中心重量都对称。若讨论第二个石子数为 0 的格子不是 (1, 1) 而是 (1, 2) 的话，选 (0, 2) 和 (2, 2) 其中任一格子移动一块石子，最后移动总数的结果都一样。

此例最小移动总数为 2+2+1+1=6 次。
