---
title: "Python 类"
subtitle: ""
layout: post
author: "L Hondong"
header-img: "img/post-bg-8.jpg"
tags:
  - Python
  - Python 类
---

# 面向过程编程与面向对象编程

- **面向过程**——以过程为中心的编程思想，以“什么正在发生”为主要目标进行编程。**冰冷的，程序化的**
- **面向对象**——将现实世界的事物抽象成对象，更关注“谁在受影响”，更加贴近现实。**有血有肉，拟人（物）化的** 

# 面向过程编程：函数

- 白箱子：输入——处理——输出
- 三要素：参数、函数体、返回值

## 参数

### 参数传递

形参与实参

- 形参（形式参数）：函数定义时的参数，实际上就是变量名
- 实参（实际参数）：函数调用时的参数，实际上就是变量的值

#### 1. 位置参数

- 严格按照位置顺序，用实参对形参进行赋值（关联）
- 实参与形参个数必须一一对应，一个不能多，一个不能少
- 一般用在参数比较少的时候

#### 2. 关键字参数

- 打破位置限制，直呼其名的进行值的传递（形参=实参）
- 必须遵守实参与形参数量上一一对应
- 多用在参数比较多的场合

**位置参数与关键字参数混合使用**

- 位置参数必须放在关键字参数前面
- 不能为同一个形参重复传值

#### 3. 默认参数

- 在定义阶段就给形参赋值——该形参的常用值
- 默认参数必须放在非默认参数后面
- 调用函数时，可以不对该形参传值，也可以按正常的形参进行传值
- **默认参数必须是不可变类型（数字、字符串、元组）**
- 让参数变成可选的

```python
def name(first_name, last_name, middle_name=None):
    if middle_name:
        return first_name+middle_name+last_name
    else:
        return first_name+last_name
```

#### 4. 可变长参数 `*args`

- 不知道会传过来多少参数 `*args`，多余的参数，打包传递给 args
- 该形参必须放在参数列表的最后
- 实参打散

```python
def foo(x, y, z, *args):
    print(x, y ,z)
    print(args)

foo(1, 2, 3, [4, 5, 6])  

>>> 1 2 3
>>> ([4, 5, 6],) # 本质还是元组，其中的元素是列表

foo(1, 2, 3, *[4, 5, 6])   # 打散的是列表、字符串、元组或集合

>>> 1 2 3
>>> (4, 5, 6) # 实参打散
```

#### 5. 可变长参数 `**kwargs`

- 多余的参数，以字典的形式打包传递给 `**kwargs`
- 字典实参打散

```python
def foo(x, y, z, **kwargs):
    print(x, y ,z)
    print(kwargs)

foo(1, 2, 3, **{"a": 4, "b": 5, "c":6})

>>> 1 2 3
>>> {'a': 4, 'b': 5, 'c': 6}
```

`*args` `**kwargs` 只是一种形式，可以将 args，kwargs 替换成合法的变量名

## 函数体与变量作用域

- 函数体就是一段只在函数被调用时，才会执行的代码，代码构成与其他代码并无不同
- 局部变量：仅在函数体内定义和发挥作用
- 全局变量：外部定义的都是全局变量，全局变量可以在函数体内直接被使用
- 通过 global 在函数体内定义全局变量

## 返回值

- 单个返回值
- 多个返回值：以元组的形式
- 可以有多个 return 语句，一旦其中一个执行，代表了函数运行的结束
- 没有 return 语句，返回值为 None

## 注意

- 函数及其参数的命名参照变量的命名
- 字母小写及下划线组合
- 有实际意义
- 应包含简要阐述函数功能的注释，注释紧跟函数定义后面
- 函数定义前后各空两行

## 单元测试：用 assert 断言

- `assert expression`
- 表达式结果为 false 的时候触发异常

```python
assert 1==1    # 条件为 true 正常执行
assert 1==2    # 条件为 false 触发异常
>>> Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
```

## map/reduce 函数

- `map()` 函数接收两个参数，一个是函数，一个是 Iterable，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回。

```python
def f(x):
    return x * x

r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
list(r)

>>> [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

`map()` 传入的第一个参数是 f，即函数对象本身。由于结果 r 是一个 Iterator，Iterator 是惰性序列，因此通过 list() 函数让它把整个序列都计算出来并返回一个 list。

`map()` 作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的 `f(x)=x^2`，还可以计算任意复杂的函数，比如，把这个 list 所有数字转为字符串：

```python
list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
>>> ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

- reduce 把一个函数作用在一个序列 [x1, x2, x3, ...] 上，这个函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累积计算，其效果就是：`reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)`

```python
from functools import reduce

def add(x, y):
    return x + y

reduce(add, [1, 3, 5, 7, 9])

>>> 25
```

如果要把序列 [1, 3, 5, 7, 9] 变换成整数 13579

```python
from functools import reduce
def fn(x, y):
    return x * 10 + y

reduce(fn, [1, 3, 5, 7, 9])
>>> 13579
```

如果考虑到字符串 str 也是一个序列，对上面的例子稍加改动，配合 `map()`，我们就可以写出把 str 转换为 int 的函数：

```python
from functools import reduce
def fn(x, y):
    return x * 10 + y

def char2num(s):
    digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
    return digits[s]

reduce(fn, map(char2num, '13579'))
>>> 13579
```

整理成一个 `str2int` 的函数就是：

```python
from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
```

还可以用 lambda 函数进一步简化成：

```python
from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

## 匿名函数

`lambda 变量：函数体`

`lambda x: x * x` 实际上就是

```python
def f(x):
    return x * x
```

- 关键字 lambda 表示匿名函数，冒号前面的 x 表示函数参数
- 匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果
- 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数 `f = lambda x: x * x`
- 在参数列表中最适合使用匿名函数，尤其是与 key = 搭配

## 排序 sort()  sorted()

- key 指定的函数将作用于 list 的每一个元素上，并根据 key 函数返回的结果进行排序。

```python
ls = [(93, 88), (79, 100), (86, 71), (85, 85), (76, 94)]
ls.sort(key = lambda x: x[1]) # 按第二个位置升序排序
>>> [(86, 71), (85, 85), (93, 88), (76, 94), (79, 100)]

ls = [(93, 88), (79, 100), (86, 71), (85, 85), (76, 94)] # 按总数排序
temp = sorted(ls, key = lambda x: x[0]+x[1], reverse=True)
>>> [(93, 88), (79, 100), (85, 85), (76, 94), (86, 71)]

ls = [(93, 88), (79, 100), (86, 71), (85, 85), (76, 94)] # 取出第二个位置的最大值
n = max(ls, key = lambda x: x[1])
>>> (79, 100)
```

- 忽略大小写来比较两个字符串

```python
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
>>> ['about', 'bob', 'Credit', 'Zoo']
```

这里的 `key=str.lower` 相当于 `key=lambda x: x.lower()`，key 的传参应该是一个函数名，而不是一个函数调用，`lower()` 的函数名就是 lower，在 string 类中定义的，`lower()` 是函数调用，所以应该是 lower。

- 根据值的大小排序字典

```python
d = {1: 'z', 2:'y', 3: 'x'}
sorted(d.items(), key=lambda x: x[1])
[(3, 'x'), (2, 'y'), (1, 'z')]
```

- 根据 value 排序的字典

```python
from collections import OrderedDict

sorted_d = OrderedDict(sorted(d.items(), key=lambda x: x[1]))
>>> OrderedDict([(3, 'x'), (2, 'y'), (1, 'z')])
```

给定一个只包含大小写字母，数字的字符串，对其进行排序，保证：

- 所有的小写字母在大写字母前面
- 所有的字母在数字前面
- 所有的奇数在偶数前面


```python
s = "Sorting1234"
"".join(sorted(s, key=lambda x: (x.isdigit(), x.isdigit() and int(x) % 2 == 0, x.isupper(), x.islower(), x)))
>>> 'ginortS1324'
```

lambda 函数将输入的字符转换为一个元组，比如 'S' 对应的为 `(False, False, True, False, 'S')`，然后 sorted 函数将根据元组（而不是字符）来进行比较，False 在 True 的前面，也就是第一个为 False 的非数字在数字的前面，进而判断每个字符的前后顺序。

### filter 函数

- `filter()` 函数用于过滤序列，把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素。

```python
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) # 删掉 list 的偶数，只保留奇数
>>> [1, 5, 9, 15]

def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  '])) # 删除一个序列中的空字符串
```

- `filter()` 函数返回的是一个 Iterator，也就是一个惰性序列，所以要强迫 `filter()` 完成计算结果，需要用 `list()` 函数获得所有结果并返回 list。

# 面向对象编程：类

- 一切皆对象
- 一切对象，都有自己内在的属性
- 一切行为，皆是对象的行为

## 类的命名

- 要有实际意义
- 驼峰命名法：组成的单词首字母大写
- 类前后空两行

## 类的属性

- 类内部的变量

```python
class Car():
    """模拟汽车"""
    
    def __init__(self, brand, model, year):
        """初始化汽车属性"""               # 相当于类内部的变量
        self.brand = brand                 # 汽车的品牌
        self.model = model                 # 汽车的型号
        self.year = year                   # 汽车出厂年份
        self.mileage = 0                   # 新车总里程初始化为0     
```

`__init__` 方法的第一个参数永远是self，表示创建的实例本身，因此，在 `__init__` 方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 `self.__brand = brand`。

不能直接访问 `__brand` 是因为 Python 解释器对外把 `__brand` 变量改成了 `_Car__brand` ，所以，仍然可以通过`_Car__brand` 来访问 `__brand` 变量：`my_car._Car__brand`，强烈建议你不要这么干，因为不同版本的 Python 解释器可能会把 `__brand` 改成不同的变量名。

如果外部代码要获取 brand 和 model，可以给 Car 类增加  get_brand 和 get_model 这样的方法：

```python
class Car(object):
    ...

    def get_brand(self):
        return self.__brand

    def get_model(self):
        return self.__model

    # 增加 set_model 方法允许外部代码修改 model
    def set_model(self, model):
        self.__model = model
```

变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以不能用 `__brand__`、`__model__` 这样的变量名。


## 类的方法

- 类内部定义的函数

`def func(self): ` self 不能省！

## 创建实例

- 将实例赋值给对象，实例化过程中，传入相应的参数

### 访问属性

- `实例名.属性名`

### 调用方法

- `实例名.方法名(必要的参数)`

### 修改属性

- 直接修改
- 通过调用方法修改属性

## 类的继承
 
1. 将**公共特征提取出来**，建立父类；  
2. 各子类继承上一级公共特征，然后添加自身特殊特征，构建各自的类。

```python
class ElectricCar(Car):
    """模拟电动汽车"""
    
    def __init__(self, brand, model, year):
        """初始化电动汽车属性"""
        super().__init__(brand, model, year)  # 声明继承父类的属性
```

- 自动继承父类的所有方法

### 多态

- 重写父类的方法

### 用在类中的实例

- 把电池抽象成一个对象，逻辑更加清晰

```python
class Bettery():
    """模拟电动汽车的电池"""
    
    def __init__(self, bettery_size = 70):
        self.bettery_size = bettery_size        # 电池容量
        self.electric_quantity = bettery_size   # 电池剩余电量
        self.electric2distance_ratio = 5        # 电量距离换算系数 5公里/kW.h
        self.remainder_range = self.electric_quantity*self.electric2distance_ratio # 剩余可行驶里程

    def get_electric_quantit(self):
        """查看当前电池电量"""
        print("当前电池剩余电量：{} kW.h".format(self.electric_quantity))
        
    def set_electric_quantity(self, electric_quantity):
        """设置电池剩余电量，重新计算电量可支撑行驶里程"""
        if electric_quantity >= 0 and electric_quantity <= self.bettery_size:
            self.electric_quantity = electric_quantity
            self.remainder_range = self.electric_quantity*self.electric2distance_ratio
        else:
            print("电量未设置在合理范围！")
    
    def get_remainder_range(self):
        """查看剩余可行驶里程"""
        print("当前电量还可以继续驾驶 {} 公里".format(self.remainder_range))

class ElectricCar(Car):
    """模拟电动汽车"""
    
    def __init__(self, brand, model, year, bettery_size):
        """初始化电动汽车属性"""
        super().__init__(brand, model, year)    # 声明继承父类的属性
        self.bettery = Bettery(bettery_size)    # 电池类的实例
    
    def get_main_information(self):        # 重写父类方法
        """获取汽车主要信息"""
        print("品牌：{}   型号：{}   出厂年份：{}   续航里程：{} 公里"
              .format(self.brand, self.model, self.year, 
              self.bettery.bettery_size*self.bettery.electric2distance_ratio))
my_electric_car = ElectricCar("NextWeek", "FF91", 2046, 70)
my_electric_car.get_main_information()                  # 获取车辆主要信息
my_electric_car.bettery.get_electric_quantit()          # 获取当前电池电量
my_electric_car.bettery.set_electric_quantity(50)       # 重设电池电量
my_electric_car.bettery.get_electric_quantit()          # 获取当前电池电量 
my_electric_car.bettery.get_remainder_range()           # 获取当前剩余可行驶里程
```

## 面向对象三大特性

面向对象的三大特性：封装、继承和多态

### 封装

封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。所以在使用面向对象的封装特性时，需要：

- 将内容封装到某处
- 从某处调用被封装的内容

### 继承

继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。对于面向对象的继承来说，其实就是将多个类共有的方法提取到父类中，子类仅需继承父类而不必一一实现每个方法。

Python 的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先，这分别体现在旧式类和新式类中：

- 当类是经典类时，多继承情况下，会按照深度优先方式查找
- 当类是新式类时，多继承情况下，会按照广度优先方式查找

对象方法的这种查找顺序在 Python 中称为 MRO(Method Resolution Order)，即方法解析顺序。查看类的 `__mro__` 属性便可只知道对象方法的查找顺序，还可以通过重写类的 `mro()` 方法来已定义对象方法的查找顺序。

### 多态

Python 不支持多态并且也用不到多态，而 Python 崇尚 **鸭子类型**。Python 的鸭子类型便相当于其他语言的多态。鸭子类型（英语：duck typing）是动态类型的一种风格。可以这样来描述鸭子模型：

> “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

鸭子类型，即不关心对象是什么类型（到底是不是鸭子），只关心行为。

比如在 Python 中，有很多 file-like 的东西，像 StringIO, GzipFile, socket 等。它们有很多相同的方法，但都可以把它们当作文件使用。

使用鸭子类型的方式通常是封装一个函数，然后执行对象（不具体关心对象的类型）的方法（只关心行为）。如扩展列表的方法 list.extend(iterable)，传递给它的参数 list/tuple/dict/字符串/生成器 等等，只要是可迭代的对象即可。

## self 变量

类方法的第一个参数必须是 `self`，这是类方法与普通函数的区别。`self` 变量指对象本身，虽然可以对这个变量做任意的命名，但不建议这么做，self 是一个约定俗成的用法。实例变量就是一个用 self 修饰的变量。self 将一个变量绑定到一个特定的实例上，这样它就属于这个实例自己。
