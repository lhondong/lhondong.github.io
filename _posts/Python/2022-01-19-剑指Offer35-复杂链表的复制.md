---
title: "剑指 Offer 35. 复杂链表的复制"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 35. 复杂链表的复制

## 题目

请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。

## 示例

示例 1:

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/剑指Offer35-复杂链表的复制-2022-01-19-20-39-12.png" alt="剑指Offer35-复杂链表的复制-2022-01-19-20-39-12" style="zoom:50%;" /></div>

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

示例 2:

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/剑指Offer35-复杂链表的复制-2022-01-19-20-39-47.png" alt="剑指Offer35-复杂链表的复制-2022-01-19-20-39-47" style="zoom:50%;" /></div>

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

示例 3:

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/剑指Offer35-复杂链表的复制-2022-01-19-20-39-59.png" alt="剑指Offer35-复杂链表的复制-2022-01-19-20-39-59" style="zoom:50%;" /></div>

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

示例 4：

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

## 题解

### 哈希表

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/剑指Offer35-复杂链表的复制-2022-01-19-20-42-01.png" alt="剑指Offer35-复杂链表的复制-2022-01-19-20-42-01" style="zoom:50%;" /></div>

利用哈希表的查询特点，考虑构建**原链表节点**和**新链表对应节点**的键值对映射关系，再遍历构建新链表各节点的 `next` 和 `random` 引用指向即可。

#### 算法流程：

1. 若头节点 `head` 为空节点，直接返回 `null`；
2. 初始化： 哈希表 `dic` ， 节点 `cur` 指向头节点；
3. 复制链表：
   - 建立新节点，并向 `dic` 添加键值对 (原 `cur` 节点, 新 `cur` 节点） ；
   - `cur` 遍历至原链表下一节点；
4. 构建新链表的引用指向：
    - 构建新节点的 `next` 和 `random` 引用指向；
    - `cur` 遍历至原链表下一节点；
5. 返回值： 新链表的头节点 dic[cur] ；

#### 复杂度分析：

- 时间复杂度 O(N) ： 两轮遍历链表，使用 O(N) 时间。
- 空间复杂度 O(N) ： 哈希表 dic 使用线性大小的额外空间。

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/剑指Offer35-复杂链表的复制-2022-01-19-20-51-24.png" alt="剑指Offer35-复杂链表的复制-2022-01-19-20-51-24" style="zoom:50%;" /></div>

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x, next=None, random=None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        if not head: return
        dict = {}
        new = head
        while new:
            dict[new] = Node(new.val) # 注意，这里 dic 里面 key 和 value 都是链表节点而不是数。
            new = new.next
        new = head
        while new:
            dict[new].next = dict.get(new.next)
            dict[new].random = dict.get(new.random)
            new = new.next
        return dict[head]
```

### 方法二：拼接 + 拆分

考虑构建 原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> …… 的拼接链表，如此便可在访问原节点的 `random` 指向节点的同时找到新对应新节点的 `random` 指向节点。

#### 算法流程：

1. 复制各节点，构建拼接链表:
    - 设原链表为 $node1→node2→⋯$，构建的拼接链表： $node1→newnode1→node2→newnode2→⋯$
2. 构建新链表各节点的 `random` 指向：
    - 当访问原节点 `cur` 的随机指向节点 `cur.random` 时，对应新节点 `cur.next` 的随机指向节点为 `cur.random.next` 。
3. 拆分原 / 新链表：
    - 设置 `pre` / `cur` 分别指向原/新链表头节点，遍历执行 `pre.next = pre.next.next` 和 `cur.next = cur.next.next` 将两链表拆分开。
4. 返回新链表的头节点 res 即可。

#### 复杂度分析：

- 时间复杂度 $O(N)$：三轮遍历链表，使用 $O(N)$ 时间。
- 空间复杂度 $O(1)$：节点引用变量使用常数大小的额外空间。

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/剑指Offer35-复杂链表的复制-2022-01-19-21-08-14.png" alt="剑指Offer35-复杂链表的复制-2022-01-19-21-08-14" style="zoom:50%;" /></div>

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x, next=None, random=None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        if not head: return
        # 第一遍循环：复制各节点，并构建拼接链表
        cur = head
        while cur:
            new = Node(cur.val)
            new.next = cur.next
            cur.next = new
            cur = cur.next.next
         # 第二遍循环：构建各新节点的 random 指向
        cur = head
        while cur:
            if cur.random:
                cur.next.random = cur.random.next
            cur = cur.next.next
        # 第三遍循环：拆分两链表
        cur = newhead = head.next
        pre = head
        while cur.next:
            pre.next = cur.next
            cur.next = cur.next.next
            pre = pre.next
            cur = cur.next
        pre.next = None # 单独处理原链表尾节点
        return newhead # 返回新链表头节点
```

注意：

1. 第三遍循环：循环到 `cur.next != Node`
2. 所有过程处理完后，要单独处理原链表尾节点！！