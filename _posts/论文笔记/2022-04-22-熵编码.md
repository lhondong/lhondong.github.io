---
title: "熵编码"
subtitle: ""
layout: post
author: "L Hondong"
header-img: "img/post-bg-47.jpg"
mathjax: true
tags:
  - 熵编码  
  - 视频编码
  - H.264
  - H.265
---
# 熵编码

熵编码：利用信源的统计特性进行码率压缩的编码，称之为熵编码，也叫做统计特性

基本思想：使前后的码字之间尽量更加随机，减少前后相关性，更加接近其信源的香农熵；

- 熵编码具有消除数据之间统计冗余的功能，在编码端作为最后一道工序，将语法元素写入输出码流；
- 熵解码作为解码过程的第一步，将码流解析出语法元素供后续步骤重建图像使用。

| 算法     | 复杂度 | 编码效率 | 代表                      |
| -------- | ------ | -------- | ------------------------- |
| 变长编码 | 低     | 低       | 哈夫曼编码；香农-费诺编码 |
| 算术编码 | 高     | 高       | 指数编码；AVLC；CABAC     |

## 变长编码

变长编码（最佳编码）：对出现概率大的符号分配短字长的二进制码，对于出现概率小的符号分配长字长的二进制码，得到符号平均码长最短的码流。

### 香农熵编码

熵在编码中，是对信息的衡量，熵越大，表明所包含的信息越多。对于高频出现的事件，其本身包含的信息其实是不多的，所以其对应的熵更小。而低频出现的事件，其包含的信息更多，对应的熵更大。香农的熵编码理论值计算公式为：

$$
H(x)=-\sum\limits^n_{i=1}p_i\log(p_i)
$$

### 哈夫曼编码

变长编码的一种，依赖于码字的概率来构造平均长度最短的编码方法；速度最快的熵编码，其基本原理是基于统计的频率，构建二叉树，最后高频率的字符用最短的编码表示，最低频率的字符用最长的编码来表示。其基本的操作就是不断构建哈夫曼树二叉树的过程。

哈夫曼树：一种特殊的二叉树，终端节点个数等同于码元数，且每个终端节点带有各自的权值；加权路径长度，即根节点到终端节点的路径长度乘以权值的总和最小。

哈夫曼编码是 “唯一可译码”，甚至还是 “即时码”。

例如，编码 “this is an example of a huffman tree”，这串字符串有 36 个字符，如果按普通方式存储这串字符串，每个字符占据 1 个字节，则共需要 36×1×8=288bit。

按字母频率来建构霍夫曼树。句中字母的编码和频率如图所示。

| 字母  | 频率 | 编码  |
| ----- | ---- | ----- |
| space | 7    | 111   |
| a     | 4    | 010   |
| e     | 4    | 000   |
| f     | 3    | 1101  |
| h     | 2    | 1010  |
| i     | 2    | 1000  |
| m     | 2    | 0111  |
| n     | 2    | 0010  |
| s     | 2    | 1011  |
| t     | 2    | 0110  |
| l     | 1    | 11001 |
| o     | 1    | 00110 |
| p     | 1    | 10011 |
| r     | 1    | 11000 |
| u     | 1    | 00111 |
| x     | 1    | 10010 |

编码这串字符串，只需要：(7+4+4)x3 + (3+2+2+2+2+2+2)x4 + (1+1+1+1+1+1)x 5 = 45+60+30 = 135bit。单单这串字符串，就压缩了 288-135 = 153bit。（不包括保存树所用的空间）

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/熵编码-2022-04-22-12-46-55.png" alt="熵编码-2022-04-22-12-46-55" style="zoom:50%;" /></div>

### 指数哥伦布编码

指数哥伦布编码同哈夫曼编码一样，都属于变长编码的一种；

二者的显著区别：

|            | 哈夫曼编码                                   | 指数哥伦布编码                   |
| ---------- | -------------------------------------------- | -------------------------------- |
| 信源相关性 | 依赖信源概率分布                             | 信源无关性                       |
| 额外信息   | 必须携带额外与信源匹配的码表                 | 无须携带任何额外信息             |
| 压缩效果   | 在不考虑码表的情况下，哈夫曼编码压缩效率更高 | 压缩率通常较低，甚至毫无压缩效果 |

H.264 中定义的指数哥伦布编码共分四类：

| 类型  | 描述                 |
| ----- | -------------------- |
| ue(v) | 无符号指数哥伦布编码 |
| se(v) | 有符号指数哥伦布编码 |
| te(v) | 截断指数哥伦布编码   |
| me(v) | 映射指数哥伦布编码   |

- 其中 ue(v) 是其他变型算法的基础，其他算法的结果由 ue(v) 的结果进一步处理得到

## 算术编码

算术编码和哈夫曼编码不同，不采用一个码字代表一个输入信息符号的办法，而采用一个浮点数来代替一串输入符号，经算术编码后输出一个小于 1，大于或者等于 0 的浮点数，在解码端再进行正确、唯一的解码，恢复原符号序列。

例如有一段非常简单的原始数据：`ARBER`

统计它们出现的次数和概率：

| Symbol | Times | P   |
| ------ | ----- | --- |
| A      | 1     | 0.2 |
| B      | 1     | 0.2 |
| E      | 1     | 0.2 |
| R      | 2     | 0.4 |

将这几个字符的区间在 [0，1) 上按照概率大小连续一字排开，我们得到一个划分好的 [0，1) 区间：

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/熵编码-2022-04-22-15-15-22.png" alt="熵编码-2022-04-22-15-15-22" style="zoom:100%;" /></div>

开始编码，初始区间是 [0，1)。注意这里又用了区间这个词，不过这个区间不同于上面代表各个字符的概率区间 [0，1)。这里我们可以称之为编码区间，这个区间是会变化的，确切来说是不断变小。我们将编码过程用下图完整地表示出来：

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/熵编码-2022-04-22-15-15-44.png" alt="熵编码-2022-04-22-15-15-44" style="zoom:100%;" /></div>

我们可以看到一个不断变化的小数编码区间。每次编码一个字符，就在现有的编码区间上，按照概率比例取出这个字符对应的子区间。例如一开始 A 落在 0 到 0.2 上，因此编码区间缩小为 [0，0.2)，第二个字符是 R，则在 [0，0.2) 上按比例取出 R 对应的子区间 [0.12，0.2)，以此类推。每次得到的新的区间都能精确无误地确定当前字符，并且保留了之前所有字符的信息，因为新的编码区间永远是在之前的子区间。最后我们会得到一个长长的小数，这个小数即神奇地包含了所有的原始数据，不得不说这真是一种非常精彩的思想。

### 解码

解码的方法显而易见，就是编码过程的逆推。从编码得到的小数开始，不断地寻找小数落在了哪个概率区间，就能将原来的字符一个个地找出来。例如得到的小数是 0.14432，则第一个字符显然是 A，因为它落在了 [0，0.2) 上，接下来再看 0.14432 落在了 [0，0.2) 区间的哪一个相对子区间，发现是 [0.6，1)， 就能找到第二个字符是 R，依此类推。

## H264 中的熵编码

H.264 针对不同的语法元素定义了不同的熵编码方法

### 熵编码和 Profile 的关系

<div align=center><img src="https://lhondong-pic.oss-cn-shenzhen.aliyuncs.com/img/assets/熵编码-2022-04-22-15-32-49.png" alt="熵编码-2022-04-22-15-32-49" style="zoom:100%;" /></div>

H264 中熵编码主要采用两种类型：CAVLA 和 CABAC。

### CAVLC

CAVLC 的全称叫做 “上下文自适应的变长编码 Context-based Adaptive Variable Length Coding”。

所谓 “上下文自适应”，说明了 CAVLC 算法不是像指数哥伦布编码那样采用固定的码流-码字映射的编码，而是一种动态编码的算法，因而压缩比远远超过固定变长编码 UVLC 等算法。

#### CAVLC 特点

上下文自适应的变长编码：

- 用于亮度和色度预测残差的编码，以量化后的变换系数的形式；
- 变换系数矩阵的特征：
- 稀疏：矩阵元素以 0 为主；
- 非零系数集中于低频；
- 高频部分的非零系数大部分为 ±1；
- 非零系数个数同相邻块有关；

CAVLC 的上下文模型：

1. 编码非零系数的表格索引；
2. 更新编码非零系数时的后缀长度

#### CAVLC 基本原理

CAVLC 用于亮度和色度残差系数的编码。残差系数经过变换量化后的数据特性：

1. 4×4 块数据经过预测、变换、量化后，非零系数主要集中在低频部分，而高频部分大部分是零；
2. 量化后的数据经过 Zig-Zag 扫描，DC 系数附近的非零系数值较大，而高频位置上的非零系数值大部分是 +1 和 -1；
3. 相邻 4×4 的非零系数的数目是相关的；

CAVLC 充分利用残差经过整数变换、量化后的数据的特性进行压缩，进一步减少数据中的冗余信息，为 H264 的编码效率的提升奠定基础。

### CABAC 介绍

CABAC (Context Adaptive Binary Arithmatic Coding) 是将自适应的二进制算术编码与一个设计精良的上下文模型结合起来得到的方法。

它很好地利用了语法元素数值之间的高阶信息，使得熵编码的效率得到了进一步提高。

#### CABAC 特点

1. 利用每个语法元素的上下文关系，根据已编码元素为待编码元素选择概率模型，即上下文建模；
2. 根据当前的统计特性自适应地进行概率估计；
3. 使用算术编码。

#### CABAC 步骤

这个编码过程主要由四个基本步骤组成：

1. 二值化：CABAC 使用二进制算数编码，这意味着仅仅有两个数字（1 或 0）被编码。一个非二进制的数值符号，比如一个转换系数或者运动适量，在算术编码之前会首先被二值化或者转化成二进制码字。这个过程类似于将一个数值转化成可变长码字，但是这个二进制码字在传输之前会通过算术编码器进一步的编码；
2. 上下文建模：上下文模型就是一个概率模型，这个模型是根据最近的被编码的数据符号的统计数字而选择的一个模型。这个模型保存了每个‘bin’是 1 或者 0 的概率；
3. 基于表格的二进制算术编码：算术编码器根据选择的概率模型对每一个‘bin’进行编码；
4. 概率更新：被选中的上下文模型会根据实际的编码值而去更新。例如，如果 bin 的值是 1，那么 1 的频率计数会增加。

### CAVLC 和 CABAC 的区别

CAVLC 大体上继承了 MPEG-2/4 的体系结构，即对出现概率高的数值采用较短的码字，以提高编码的效率。

H.264 的改进是在对一些特定的数据编码时，使用已编码的数据来预测当前符号使用的编码模型，这样也能够提高编码效率。

为了使 H.264 标准能够很好的支持 HDTV 电视信号压缩，JVT 工作组采用了内容自适应二进制算术编码 (CABAC)。

与 CAVLC 相比，虽然在计算的复杂性上有所增加，但在编码效率上可以提高了大概 10% 左右，特别是在对隔行电视信号进行编解码时会获得最大的效率上的提高。

CABAC 在编码数据元素的自适应范围上比 CAVLC 更加广泛。

**当采用了 CABAC 编码时**：从**宏块类型** (macroblock+type) 开始，包括**帧内运动向量模式**，和**各种编码标志**以及**图像的残留数据**在内的所有图像数据都是使用 CABAC 编码，这样就大大提高了数据压缩率；

**若使用 CAVLC 编码**：只有在对**变换系数**的编码时才采用自适应的模式。
