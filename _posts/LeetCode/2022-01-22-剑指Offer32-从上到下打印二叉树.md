---
title: "剑指 Offer 32 - II. 从上到下打印二叉树 II"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 32 - II. 从上到下打印二叉树 II

## 题目

## 示例

例如:
给定二叉树: [3,9,20,null,null,15,7],

示例 1:

```
    3
   / \
  9  20
    /  \
   15   7
```

返回：[3,9,20,15,7]

## 题解

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root: return []
        res = []
        queue = collections.deque()
        queue.append(root)
        while queue:
            node = queue.popleft()
            res.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        return res
```

## 笔记

二叉树的广度优先搜索。

queue 中存放节点 node，当 queue 中没有节点之后，说明全部节点循环完成。res 列表中存放结果。

Python 中使用 collections 中的双端队列 deque() ，其 popleft() 方法可达到 O(1) 时间复杂度；而如果使用简单的列表 queue，queue.pop(0) 可以达到相同的效果，但是时间复杂度为 O(N)。

### deque

使用list存储数据时，按索引访问元素很快，可是插入和删除元素就很慢了，由于list是线性存储，数据量大的时候，插入和删除效率很低。python 中 deque是为了高效实现插入和删除操做的双向列表，适合用于队列和栈：

```python
from collections import deque
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
q
deque(['y', 'a', 'b', 'c', 'x'])
```

deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就能够很是高效地往头部添加或删除元素。

## 附加

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:
给定二叉树: [3,9,20,null,null,15,7],


```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

<div align=center><img src="/assets/剑指Offer32-从上到下打印二叉树-2022-01-22-20-46-54.png" alt="剑指Offer32-从上到下打印二叉树-2022-01-22-20-46-54" style="zoom:50%;" /></div>

## 题解

用 for 循环控制每一层的循环次数，该层的所有节点结果放在 tmp 列表中，该层循环结束，将 tmp 放入最终结果 res。

```python
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root: return []
        res = []
        queue = collections.deque()
        queue.append(root)
        while queue:
            tmp = []
            for _ in range(len(queue)):
                node = queue.popleft()
                tmp.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            res.append(tmp)
        return res
```