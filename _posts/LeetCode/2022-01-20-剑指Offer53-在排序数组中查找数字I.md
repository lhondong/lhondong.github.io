---
title: "剑指 Offer 53 - I. 在排序数组中查找数字 I"
subtitle: "LeetCode 刷题笔记"
layout: post
author: "L Hondong"
header-img: "img/post-bg-12.jpg"
mathjax: ture
tags:
  - LeetCode
  - 算法
---

# 剑指 Offer 53 - I. 在排序数组中查找数字 I

## 题目

统计一个数字在排序数组中出现的次数。

## 示例

示例 1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

示例 2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

## 题解

二分查找。

<div align=center><img src="../assets/剑指 Offer53-在排序数组中查找数字I-2022-01-20-22-13-25.png" alt="剑指 Offer53-在排序数组中查找数字I-2022-01-20-22-13-25" style="zoom:50%;" /></div>

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # 搜索右边界 right
        low = 0
        high = len(nums) - 1
        while low <= high:
            mid = (high + low) // 2
            if nums[mid] <= target: low = mid + 1
            else: high = mid - 1
        right = low
        # 若数组中无 target ，则提前返回
        if high >= 0 and nums[high] != target: return 0
        # 搜索左边界 left
        low = 0
        while low <= high:
            mid = (high + low) // 2
            if nums[mid] = target: low = mid + 1
            else: high = mid - 1
        left = high
        return right - left - 1
```

二分查找找出右边界和左边界，其中 `if nums[mid] <= target: low = mid + 1` 用来找右边界，`if nums[mid] = target: low = mid + 1` 用来找右边界。

以上代码显得比较臃肿（两轮二分查找代码冗余）。为简化代码，可将二分查找右边界 `right` 的代码封装至函数 helper() 。

<div align=center><img src="../assets/剑指 Offer53-在排序数组中查找数字I-2022-01-20-22-21-48.png" alt="剑指 Offer53-在排序数组中查找数字I-2022-01-20-22-21-48" style="zoom:50%;" /></div>

如上图所示，由于数组 `nums` 中元素都为整数，因此可以分别二分查找 `target` 和 `target−1` 的右边界，将两结果相减并返回即可。

本质上看， helper() 函数旨在查找数字 target 在数组 nums 中的**插入点**，且若数组中存在值相同的元素，则插入到这些元素的右边。

```python
class Solution:
    def search(self, nums: [int], target: int) -> int:
        def helper(tar):
            low, high = 0, len(nums) - 1
            while low <= high:
                mid = (low + high) // 2
                if nums[mid] <= tar: low = mid + 1
                else: high = mid - 1
            return low
        return helper(target) - helper(target - 1)
```