---
title: "Linux 命令"
subtitle: "Linux 命令整理"
layout: post
author: "L Hondong"
header-img: "img/post-bg-15.jpg"
tags:
  - Linux
---

# Linux 命令

## 基本指令

|指令|作用|
|---|---|
|sudo {指令}|为指令增加暂时的超级权限|
|cd {path}|进入某个目录|
|ls {path}|显示某个目录的内容|
|mkdir {filename}|创建目录|
|cp {file} {path}|将 file 文件拷贝到 path 目录下 ，文件夹 -r|
|rm {file}|移除 file 文件，文件夹 -rf|
|mv {file1} {file2} /{path}|如果是文件到文件，则是改名，文件到路径，则是移动， 文件夹 -r|
|chmod ‘u+x’ -R filename|修改文件的权限，递归修改文件夹内所有文件（-R）|

## chmod

### 用户说明

|用户|用户类型|说明|
|---|---|---|
|u|uer|文件拥有者|
|g|group|文件所有者所在组|
|a|others|所有其他用户|

### 权限说明

|权限|说明|
|---|---|
|r|读|
|w|写|
|x|执行|

## 进程指令

|指令|作用|
|---|---|
|nvidia-smi -i|查看显卡情况，几号显卡|
|watch -n 0.5 nvidia-smi -i|按照 0.5 的频率查看显卡情况，几号显卡|
|CUDA_VISIBLE_DEVICES=0 {command}|指定显卡运行程序|
|top -c -u username|查看进程情况，以及具体运行指令，-u 指定用户|
|kill -9 ID|根据进程 ID kill 进程|
|nohup {command} &（>dev/null 2 >log &）|后台运行程序，输出错误日志|
|nohup {command} &（>dev/null 2 >&1 &）|后台运行程序，不输出任何日志|

## 目录
1. 统计当前目录下文件的个数（不包括目录）  
```shell
ls -l | grep "^-" | wc -l
ls -l | grep -c '^-' # `grep -c "^-"` 后面的正则表达式表示匹配以"-"字符开头的行，-c 选项就表示统计个数。这样组合就达到了统计当前目录中文件个数的目的。
```
2. 统计当前目录下文件的个数（包括子目录）  
```shell
ls -lR| grep "^-" | wc -l # -R 表示递归所有子目录
```
3. 查看某目录下文件夹（目录）的个数（包括子目录）  
```shell
ls -lR | grep "^d" | wc -l # 文件夹是以字符 "d" 开头。
```
4. 查看文件夹中所有以md结尾的文件个数
```shell
ls -lR | grep "^-" | grep -c "md$"
```

## Linux 管道命令（pipe）

### 命令执行顺序控制
通常情况下，在终端只能执行一条命令，然后按下回车执行，那么如何执行多条命令呢？

- 顺序执行多条命令：`command1;command2;command3;`，简单的顺序指令可以通过 `;` 来实现
- 有条件的执行多条命令：`which command1 && command2 || command3`
  - `&&`: 如果前一条命令执行成功则执行下一条命令，如果 command1 执行成功（返回 0），则执行 command2
  - `||` : 与&&命令相反，执行不成功时执行这个命令
- $?: 存储上一次命令的返回结果

### 管道命令
管道是一种通信机制，通常用于进程间的通信（也可通过 socket 进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。

管道命令使用 `|` 作为界定符号，管道命令与上面说的连续执行命令不一样。

- 管道命令仅能处理 standard output, 对于 standard error output 会予以忽略。
  - less,more,head,tail... 都是可以接受 standard input 的命令，所以他们是管道命令
  - ls,cp,mv 并不会接受 standard input 的命令，所以他们不是管道命令
- 管道命令必须要能够接受来自前一个命令的数据成为 standard input 继续处理才行。

```shell
$ ls -al /etc | less
```

通过管道将 ls -al 的输出作为 下一个命令 less 的输入，方便浏览。

### 选取命令：cut.grep

#### cut: 从某一行信息中取出某部分我们想要的信息

- -d : '分隔字符' -f field // 用于分隔字符，通常与 -f 一起使用
- -f : 根据-d 将信息分隔成数段，-f 后接数字 表示取出第几段
- -c : 以字符为单位取出固定字符区间的信息

```shell
打印/etc/passwd 文件中以：为分隔符的第 1 个字段和第 6 个字段分别表示用户名和家目录
[root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | cut -d ':' -f 1,6
root:/root
bin:/bin
daemon:/sbin
adm:/var/adm
lp:/var/spool/lpd
...
```

```shell
打印/etc/passwd 文件中每一行的前 10 个字符：
[root@izuf6i29flb2df231kt91hz /]# cat /etc/passwd | cut -c 1-10
root:x:0:0
bin:x:1:1:
daemon:x:2
adm:x:3:4:
lp:x:4:7:l
...
```

注：cut 在处理多空格相连的数据时，比较吃力。

#### grep: 分析一行信息，如果其中有我们需要的信息，就将该行拿出来

grep [-acinv] [--color=auto] '查找字符串' filename

- -a : 将 binary 文件以 text 文件的方式查找数据
- -c : 计算找到'查找字符串'的次数
- -i : 忽略大小写的不同
- -n : 输出行号
- -v : 反向选择，显示没有查找内容的行
- --color=auto : 将找到的关键字部分加上颜色显示

```shell
取出含有 fanco 的/etc/passwd 文件的行
[root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | grep -n -c 'fanco'
1
[root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | grep -n 'fanco'
23:fanco:x:1001:1001::/home/fanco:/bin/bash
[root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | grep -n -v 'fanco'
1:root:x:0:0:root:/root:/bin/bash
2:bin:x:1:1:bin:/bin:/sbin/nologin
3:daemon:x:2:2:daemon:/sbin:/sbin/nologin
4:adm:x:3:4:adm:/var/adm:/sbin/nologin
5:lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
...
```

### 排序命令：sort, wc, uniq

#### sort

sort [-选项] [file or stdin]

- -f ：忽略大小写的差异，例如 A 与 a 视为编码相同
- -b ：忽略最前面的空格部分
- -c ：检查文件是否已经按照顺序排序
- -M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法
- -n ：使用**纯数字**进行排序（默认是以文字型态来排序的）
- -r ：反向排序
- -u ：就是 uniq ，相同的资料中，仅出现一行代表
- -t ：分隔符号，预设是用 [tab] 键来分隔
- -o ：<输出文件> 将排序后的结果存入指定的文件
- -k ：以那个区间 (field) 来进行排序的意思

```shell
对/etc/passwd 的账号进行排序
[root@izuf6i29flb2df231kt91hz /]# cat /etc/passwd | sort
adm:x:3:4:adm:/var/adm:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
chrony:x:998:996::/var/lib/chrony:/sbin/nologin
...
通过/etc/passwd 第 5 列来进行排序
[root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
fanco:x:1001:1001::/home/fanco:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
这里排序还是按照文字进行排序的，切换成数字排序
[root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | sort -t ':' -k 3 -n
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
```

#### uniq

uniq [-选项]

- -i ：忽略大小写的不同
- -c ：显示输出中，在每行行首加上本行在文件中出现的次数。它可取代 -u 和 -d 选项
- -d ：只显示重复行
- -u ：只显示文件中不重复的各行
- -n ：前 n 个字段与每个字段前的空白一起被忽略。一个字段是一个非空格、非制表符的字符串，彼此由制表符和空格隔开(字段从0开始编号)
- +n ：前 n 个字符被忽略，之前的字符被跳过(字符从0开始编号)
- -f ：n 与 -n 相同，这里 n 是字段数。<栏位>或--skip-fields=<栏位> 忽略比较指定的栏位。
- -s ：n 与 +n 相同，这里 n 是字符数。<字符位置>或--skip-chars=<字符位置> 忽略比较指定的字符。

```shell
使用 last 取出历史登录信息的账号，排序，去重
[root@izuf6i29flb2df231kt91hz /]# last | cut -d ' ' -f 1 | sort | uniq -c
      1 
      7 reboot
     19 root
      1 wtmp
```

```shell
sort filename | uniq -c
```   

以上操作对文件进行排序，并去除重复的行，同时在行首显示重复出现的次数。

#### wc

wc [-lwm]

- -l ：仅列出行
- -w ：仅列出多少字（英文单字）
- -m ：多少字符

```shell
查看 etc/passwd 中有多少账号
[root@izuf6i29flb2df231kt91hz /]# cat /etc/passwd | wc -l
23
计算最近登录系统的人次
[root@izuf6i29flb2df231kt91hz /]# last | grep [a-zA-Z] | grep -v 'wtmp' | wc -l
2
查看某个文件的行数 字数 字符数
[root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | wc
     23      32     997
```

## Ubuntu 如何查看版本信息

1. 使用命令： cat /proc/version 查看
2. 使用命令： uname -a 查看
3. 使用命令： lsb_release -a 查看

## 上传服务器

把本地的 source.txt 文件拷贝到 192.168.0.10 机器上的/home/work 目录下
```
scp /home/work/source.txt work@192.168.0.10:/home/work/ 
```  

把 192.168.0.10 机器上的 source.txt 文件拷贝到本地的/home/work 目录下
```
scp work@192.168.0.10:/home/work/source.txt /home/work/   
```

把 192.168.0.10 机器上的 source.txt 文件拷贝到 192.168.0.11 机器的/home/work 目录下
```
scp work@192.168.0.10:/home/work/source.txt work@192.168.0.11:/home/work/   
```

拷贝文件夹，加-r 参数
```
scp -r /home/work/sourcedir work@192.168.0.10:/home/work/   
```

## 查找指令

### find

```shell
find .      #查找当前目录
find /home  #把 home 目录下的文件路径都显示出来
find /home -name "yezm.txt" -maxdepth 1   #查看/home 下的文件，返回 yezm.txt 的路径，-maxdepth 限制深度 1 层
find /path -type d (f)   #代表搜索的是 d: 目录，   f: 文件
find -user   #代表搜索某个用户下的文件
find /path -maxdepth 1 -type f -exec ls{}
"""根据时间戳查找文件，下列以天为单位"""
-atime（文件最后访问时间）
-mtime（文件最后修改时间）
-ctime（文件最后改变时间）
单位：
-amin
-mmin
-cmin
"""
#：[#, #-1) ：最后访问时间在#天前（大于等于#天前，小于#-1 天前），等价于最后访问时间与当前的时间差大于 (#-1)*24 小时，小于等于 #*24 小时
-#：(#, 0] ：最后访问时间在#天以内，不包括 24 小时前的那一刻，等价于最后访问时间与当前的时间差小于 #*24 小时
+#：(oo, #-1] ：最后访问时间在#-1 天以前的。包括#-1 天前，等价于最后访问时间与当前的时间差大于等于 #*24 小时
"""
```

### which

不同于 find 指令，which 指令是在 PATH 变量指定的路径中，搜索系统命令的位置，通过 which 可以锁定当前使用的软件的位置，重点是在系统（用户）的 PATH 变量内搜索的，具体下列：

```shell
which pip
result:/opt/anaconda/anaconda3/bin/pip
which python
result: /opt/anaconda/anaconda3/bin/python
```

### whereis

whereis 命令用于程序名的搜索，而且只搜索二进制文件（参数-b)、man 说明文件（参数-m)、源代码文件（参数-s).

和 find 相比，whereis 查找的速度非常快，因为 Linux 系统会将系统内的所有文件都记录在一个数据库文件中，当使用 whereis 和 locate 时，会从数据库中查找数据，而不是像 find 那样通过遍历硬盘来查找，效率自然会很高。

但是数据库文件并不是实时更新的，因此在用 whereis 和 locate 查找文件时，有时会找到已经被删除的数据，或者刚建立的文件无法被查找到，原因就使因为数据库文件没有被更新。

### locate

locate 让使用者可以很快速的搜索档案系统内是否有指定的档案。其方法就是先建立一个包括系统内所有档案名称及路径的资料库，之后当寻找时只需要查询这个资料库，而不必深入系统文件中查找了。

参数格式：
-u: 从根目录开始建立资料库。
-U：从指定位置开始建立资料库
-e: 将某些路径排除在寻找的范围外。
-n: 指定最多显示查找到的文件的个数

## 存储指令

### free

```shell
free -g  --查看系统的内存大小，以 g 为单位
```

返回结果：
- totol: 总的内存大小
- userd: 已经使用的内存大小
- free: 除了 buff/cache，还剩下多少内存未使用
- share: 共享内存
- buff/cache: 缓冲区的内存占用情况，page cache. 在内存不够用的时候，会自动使用这部分缓存。
- available: 真实可用的内存数。

buff/cache 可以通过手动清除进行缓存的释放：

```shell
sudo sh -c "echo 1 > /proc/sys/vm/drop_caches"  //1 释放 page cache ；2 释放 dentries 和 inodes；3 全部释放
```

### du -sh

查看文件大小

```shell
du -sh  #查看当前目录的总大小
du -sh /path/ * #查看目录下各个文件的大小
du -h /path/ * -d 2 表示查看目录下的文件大小， -d 指最大深度 --max-depth=2 
df -h  #列出磁盘总容量，可用容量，使用百分比。
```

## 重定向

### 输出描述符

|类型|文件描述符|默认情况|对应文件句柄位置|
|---|---|---|---|
|标准输入|0|从键盘获得输入|/proc/self/fd/0|
|标准输出|1|输出到屏幕|/proc/self/fd/1|
|标准输入|2|输出到屏幕|/proc/self/fd/2|

### 输出重定向

|类型|文件描述符|
|---|---|
|command >filename|标准输出重定向到新的文件中|
|command 1>filename|同上|
|command >>filename|把标准输出追加到新文件中|
|command 1>>filename|同上|
|command 2>filename|把标准错误重定向到新文件中|
|command 2>>filename|把标准错误追加到新文件中|

## 解压缩

### .tar
```shell
解包：tar xvf FileName.tar  
tar xvf FileName.tar -C DirName（解压到指定文件夹 DirName）  
打包：tar cvf FileNametar DirName
```

### .gz
```shell
解压 1：gunzip FileName.gz  
解压 2：gzip -d FileName.gz  
压缩：gzip FileName
```

### .tar.gz 和 .tgz
```shell
解压：tar zxvf FileName.tar.gz  
压缩：tar zcvf FileName.tar.gz FileName
```

### .bz2
```shell
解压 1：bzip2 -d FileName.bz2  
解压 2：bunzip2 FileName.bz2  
压缩： bzip2 -z FileName
```
### .tar.bz2
```shell
解压：tar jxvf FileName.tar.bz2  
压缩：tar jcvf FileName.tar.bz2 FileName
```

### .bz
```shell
解压 1：bzip2 -d FileName.bz  
解压 2：bunzip2 FileName.bz  
压缩：未知
```
### .tar.bz
```shell
解压：tar jxvf FileName.tar.bz  
压缩：tar jcvf FileName.tar.bz FileName
```

### .z
```shell
解压：uncompress FileName.Z  
压缩：compress FileName.tar.z  
解压：tar zxvf FileName
```
### .tar.z
```shell
解压：tar zxvf FileName.tar.z  
压缩：tar zcvf FileName.tar.z DirName
```

### .zip
```shell
解压：unzip FileName.zip  
压缩：zip FileName.zip DirName
```

### .rar
```shell
解压：rar x FileName.rar  
压缩：rar a FileName.rar DirName  
rar 请到：http://www.rarsoft.com/download.htm 下载  
解压后请将 rar_static 拷贝到/usr/bin 目录（其他由$PATH 环境变量指定的目录也可以）[root@www2 tmp]# cp rar_static /usr/bin/rar
```

### .lha
```shell
解压：lha -e FileName.lha  
压缩：lha -a FileName.lha FileName  
lha 请到：http://www.infor.kanazawa-it.ac.jp/~ishii/lhaunix/下载！  
解压后请将 lha 拷贝到/usr/bin 目录（其他由$PATH 环境变量指定的目录也可以）[root@www2 tmp]# cp lha /usr/bin/
```

### .rpm
```shell
解包：rpm2cpio FileName.rpm | cpio -div
```

### .deb
```shell
解包：ar p FileName.deb data.Tar.gz | Tar zxf -
```

##  用户命令

```shell
sudo adduer --home /home/Username Username   #添加用户，并且生成用户目录
sudo passwd Username   #修改用户的用户密码
sudu userdel -r Username # 删除所有与用户有关（需要先把该用户的所有进程关闭）
```

adduser 和 useradd 指令不同，useradd 只会添加一个用户，没有创建它的主目录，除了添加一个新用户之外什么都没有。这个用户甚至不能登录，因为没有密码。正确的做法是 man page 里说的，adduser，这个命令实际是一个 perl 脚本，是 useradd 等类似底层命令的更友好的前端，它会用交互性的方式建立新用户，使用它可以指定新用户的家目录，登录密码，是否加密主目录等等。adduser 会：

1. 建立一个新目录作为家目录
2. 建立同名新组
3. 把用户的主要组设为该组（除非命令选项覆盖以上默认动作，比如–disall-homdirecry 之类）
4. 从/etc/SKEL 目录下拷贝文件到家目录，完成初始化
5. 建立新用户的密码
6. 如果其存在的话，还会执行一个脚本。